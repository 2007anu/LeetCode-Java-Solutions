@Library('common-pipelines@v10.0.109') _
// -----------------------------------------------------------------------------------
// The following params are automatically provided by the callback gateway as inputs
// to the Jenkins pipeline that starts this job.
//
// params["SHA"]                    - Sha used to start the pipeline
// params["BRANCH_NAME"]            - Name of GitHub branch the SHA is associated with
// params["UNIQUE_BUILD_ID"]        - A randomly generated unique ID for this job run
// params["ENQUEUED_AT_TIMESTAMP"]  - Unix timestamp generated by callback gateway
// params["JSON"]                   - Extensible json doc with extra information
// params["GITHUB_REPOSITORY"]      - GitHub ssh url of repository (git://....)
// -----------------------------------------------------------------------------------

docker = new org.doordash.Docker()
doorctl = new org.doordash.Doorctl()
github = new org.doordash.Github()
pulse = new org.doordash.Pulse()

gitUrl = params["GITHUB_REPOSITORY"]
sha = params["SHA"]


/**
 * Returns the service name which is useful for builds and deployments.
 */
def getServiceName() {
  return 'payment-service'
}


/**
 * Returns the service docker image url which is useful for builds and deployments.
 */
def getDockerImageUrl() {
  def serviceName = getServiceName()
  return "ddartifacts-docker.jfrog.io/doordash/${serviceName}"
}


/**
 * Build, Tag, and Push a Docker image for a Microservice.
 * If there already exists a docker image for the sha, then it will skip 'make build tag push'.
 * <br>
 * <br>
 * Requires:
 * <ul>
 * <li>Makefile with build, tag, and push targets
 * </ul>
 * Provides:
 * <ul>
 * <li>branch = GitHub branch name
 * <li>doorctl = Path in order to execute doorctl from within the Makefile
 * <li>SHA = GitHub SHA
 * <li>CACHE_FROM = url:tag of recent Docker image to speed up subsequent builds that use the --cache-from option
 * <li>ARTIFACTORY_USERNAME = Artifactory Username to install Python packages
 * <li>ARTIFACTORY_PASSWORD = Artifactory Password to install Python packages
 * <li>FURY_TOKEN = Gemfury Token to install Python packages
 * </ul>
 */
def buildTagPush(Map optArgs = [:], String gitUrl, String sha, String branch, String serviceName) {
  Map o = [
          dockerDoorctlVersion: 'v0.0.118',
          dockerImageUrl      : getDockerImageUrl()
  ] << optArgs
  String loadedCacheDockerTag
  try {
    sh """|#!/bin/bash
          |set -ex
          |docker pull ${o.dockerImageUrl}:${sha}
          |""".stripMargin()
    println "Docker image was found for ${o.dockerImageUrl}:${sha} - Skipping 'make build tag push'"
    loadedCacheDockerTag = sha
  } catch (oops) {
    println "No docker image was found for ${o.dockerImageUrl}:${sha} - Running 'make build tag push'"
  }
  if (loadedCacheDockerTag == null) {
    loadedCacheDockerTag = docker.findAvailableCacheFrom(gitUrl, sha, o.dockerImageUrl)
    if (loadedCacheDockerTag == null) {
      loadedCacheDockerTag = "noCacheFoundxxxxxxx"
    }
    String doorctlPath
    sshagent(credentials: ['DDGHMACHINEUSER_PRIVATE_KEY']) {
      doorctlPath = doorctl.installIntoWorkspace(o.dockerDoorctlVersion)
    }
    String cacheFromValue = "${o.dockerImageUrl}:${loadedCacheDockerTag}"
    github.doClosureWithStatus({
      withCredentials([
        string(credentialsId: 'ARTIFACTORY_MACHINE_USER_NAME', variable: 'ARTIFACTORY_USERNAME'),
        string(credentialsId: 'ARTIFACTORY_MACHINE_USER_PASS', variable: 'ARTIFACTORY_PASSWORD'),
        string(credentialsId: 'FURY_TOKEN', variable: 'FURY_TOKEN')
      ]) {
        sh """|#!/bin/bash
              |set -ex
              |make build tag push \\
              | branch=${branch} \\
              | doorctl=${doorctlPath} \\
              | SHA=${sha} \\
              | CACHE_FROM=${cacheFromValue} \\
              | FURY_TOKEN=${FURY_TOKEN}
              |""".stripMargin()
      }
    }, gitUrl, sha, "Docker Build Tag Push", "${BUILD_URL}testReport")
  }
}

/**
 * Runs a local container useful to run CI tests on
 */
def runCIcontainer(String serviceName, String sha) {
  def dockerImageUrl = getDockerImageUrl()
  github.doClosureWithStatus({
    withCredentials([
      string(credentialsId: 'ARTIFACTORY_MACHINE_USER_NAME', variable: 'ARTIFACTORY_USERNAME'),
      string(credentialsId: 'ARTIFACTORY_MACHINE_USER_PASS', variable: 'ARTIFACTORY_PASSWORD'),
      string(credentialsId: 'FURY_TOKEN', variable: 'FURY_TOKEN')
    ]) {
      sh """|#!/bin/bash
            |set -eox
            |docker rm ${serviceName}-ci || true
            |FURY_TOKEN=${FURY_TOKEN} docker run -d --name ${serviceName}-ci ${dockerImageUrl}:${sha} tail -f /dev/null
            |""".stripMargin()
    }
  }, gitUrl, sha, "Unit Tests", "${BUILD_URL}testReport")
}


def loadJunit(fileName) {
  def fe = fileExists "${fileName}"
  if(fe) {
    junit "${fileName}"
    archiveArtifacts artifacts: "${fileName}"
  } else {
    currentBuild.result = 'UNSTABLE'
  }
}


/**
 * Run Unit Tests on the CI container and archive the report
 */
def runTests(String serviceName) {
  github.doClosureWithStatus({
    withCredentials([
      string(credentialsId: 'ARTIFACTORY_MACHINE_USER_NAME', variable: 'ARTIFACTORY_USERNAME'),
      string(credentialsId: 'ARTIFACTORY_MACHINE_USER_PASS', variable: 'ARTIFACTORY_PASSWORD'),
      string(credentialsId: 'FURY_TOKEN', variable: 'FURY_TOKEN')
    ]) {
      try {
        sh """|#!/bin/bash
              |set -eox
              |FURY_TOKEN=${FURY_TOKEN} docker exec ${serviceName}-ci tox -e py37
              |""".stripMargin()
      } finally {
        sh """|#!/bin/bash
              |set -eox
              |docker cp ${serviceName}-ci:/home/app/pytest-report.xml pytest.xml
              |""".stripMargin()
        loadJunit("pytest.xml")
      }
    }
  }, gitUrl, sha, "Unit Tests", "${BUILD_URL}testReport")
}


/**
 * Run the linter on the CI container and archive the report
 */
def runLinter(String serviceName) {
  github.doClosureWithStatus({
    withCredentials([
      string(credentialsId: 'ARTIFACTORY_MACHINE_USER_NAME', variable: 'ARTIFACTORY_USERNAME'),
      string(credentialsId: 'ARTIFACTORY_MACHINE_USER_PASS', variable: 'ARTIFACTORY_PASSWORD'),
      string(credentialsId: 'FURY_TOKEN', variable: 'FURY_TOKEN')
    ]) {
      try {
        sh """|#!/bin/bash
              |set -eox
              |FURY_TOKEN=${FURY_TOKEN} docker exec ${serviceName}-ci tox -e lint
              |""".stripMargin()
      } finally {
        sh """|#!/bin/bash
              |set -eox
              |docker cp ${serviceName}-ci:/home/app/flake8-report.xml flake8.xml
              |""".stripMargin()
        loadJunit("flake8.xml")
      }
    }
  }, gitUrl, sha, "Linting", "${BUILD_URL}testReport")
}


/**
 * Run the static type checker on the CI container and archive the report
 */
def runMypy(String serviceName) {
  github.doClosureWithStatus({
    withCredentials([
      string(credentialsId: 'ARTIFACTORY_MACHINE_USER_NAME', variable: 'ARTIFACTORY_USERNAME'),
      string(credentialsId: 'ARTIFACTORY_MACHINE_USER_PASS', variable: 'ARTIFACTORY_PASSWORD'),
      string(credentialsId: 'FURY_TOKEN', variable: 'FURY_TOKEN')
    ]) {
      try {
        sh """|#!/bin/bash
              |set -eox
              |FURY_TOKEN=${FURY_TOKEN} docker exec ${serviceName}-ci tox -e mypy
              |""".stripMargin()
      } finally {
        sh """|#!/bin/bash
              |set -eox
              |docker cp ${serviceName}-ci:/home/app/mypy-report.xml mypy.xml
              |""".stripMargin()
        loadJunit("mypy.xml")
      }
    }
  }, gitUrl, sha, "Typing", "${BUILD_URL}testReport")
}


/**
 * Deploy a Microservice using Helm.
 */
def deployHelm(Map optArgs = [:], String gitUrl, String sha, String branch, String serviceName, String env) {
  Map o = [
          helmCommand: 'upgrade',
          helmFlags: '--install',
          helmChartPath: "_infra/charts/${serviceName}",
          helmValuesFile: "values-${env}.yaml",
          helmRelease: serviceName,
          k8sCredFileCredentialId: "K8S_CONFIG_${env.toUpperCase()}_NEW",
          k8sNamespace: env,
          tillerNamespace: env,
          timeoutSeconds: 600
  ] << serviceNameEnvToOptArgs(serviceName, env) << optArgs
  withCredentials([file(credentialsId: o.k8sCredFileCredentialId, variable: 'k8sCredsFile')]) {
    sh """|#!/bin/bash
          |set -ex
          |
          |helm="docker run --rm -v ${k8sCredsFile}:/root/.kube/config -v ${WORKSPACE}:/apps alpine/helm:2.10.0"
          |HELM_OPTIONS="${o.helmCommand} ${o.helmRelease} ${o.helmChartPath} \\
          | --values ${o.helmChartPath}/${o.helmValuesFile} --set web.tag=${sha} ${o.helmFlags} \\
          | --tiller-namespace ${o.tillerNamespace} --namespace ${o.k8sNamespace} \\
          | --wait --timeout ${o.timeoutSeconds}"
          |
          |# log manifest to CI/CD
          |\${helm} \${HELM_OPTIONS} --debug --dry-run
          |
          |\${helm} \${HELM_OPTIONS}
          |""".stripMargin()
  }
}


/**
 * Deploy Pulse for a Microservice.
 */
def deployPulse(Map optArgs = [:], String gitUrl, String sha, String branch, String serviceName, String env) {
  Map o = [
          k8sNamespace: env,
          pulseVersion: '2.1',
          pulseDoorctlVersion: 'v0.0.118',
          pulseRootDir: 'pulse'
  ] << serviceNameEnvToOptArgs(serviceName, env) << optArgs

  String PULSE_VERSION = o.pulseVersion
  String SERVICE_NAME = serviceName
  String KUBERNETES_CLUSTER = o.k8sNamespace
  String DOORCTL_VERSION = o.pulseDoorctlVersion
  String PULSE_DIR = o.pulseRootDir

  sshagent(credentials: ['DDGHMACHINEUSER_PRIVATE_KEY']) {
    // install doorctl and grab its executable path
    String doorctlPath = doorctl.installIntoWorkspace(DOORCTL_VERSION)
    // deploy Pulse
    pulse.deploy(PULSE_VERSION, SERVICE_NAME, KUBERNETES_CLUSTER, doorctlPath, PULSE_DIR)
  }
}


/**
 * Given a service name and environment name like 'sandbox1', 'staging', and 'production',
 * resolve the optional arguments that vary per environment.
 */
def serviceNameEnvToOptArgs(String serviceName, String env) {
  if (env ==~ /^sandbox([0-9]|1[0-5])/) { // sandbox0 - sandbox15
    return [
            helmFlags: '--install --force',
            helmValuesFile: "values-${env}.yaml",
            helmRelease: "${serviceName}-${env}",
            k8sCredFileCredentialId: 'K8S_CONFIG_STAGING_NEW',
            k8sNamespace: 'staging',
            tillerNamespace: 'staging'
    ]
  } else if (env == 'staging') {
    return [
            helmFlags: '--install --force',
            helmValuesFile: 'values-staging.yaml',
            helmRelease: serviceName,
            k8sCredFileCredentialId: 'K8S_CONFIG_STAGING_NEW',
            k8sNamespace: 'staging',
            tillerNamespace: 'staging'
    ]
  } else if (env == 'prod' || env == 'production') {
    return [
            helmFlags: '--install',
            helmValuesFile: 'values-prod.yaml',
            helmRelease: serviceName,
            k8sCredFileCredentialId: 'K8S_CONFIG_PROD_NEW',
            k8sNamespace: 'prod',
            tillerNamespace: 'prod'
    ]
  } else {
    error("Unknown env value of '${env}' passed.")
  }
}


def removeAllContainers() {
  sh """|#!/bin/bash
        |set -x
        |docker ps -a -q | xargs --no-run-if-empty docker rm -f || true
        |""".stripMargin()
}


/**
 * Prompt the user to decide if we can deploy to production.
 * The user has 10 minutes to choose between Proceed or Abort.
 * If Proceed, then we should proceed. If Abort or Timed-out,
 * then we should cleanly skip the rest of the steps in the
 * pipeline without failing the pipeline.
 *
 * @return True if we can deploy to prod. False, otherwise.
 */
def inputCanDeployToProd() {
  boolean canDeployToProd = false
  try {
    timeout(time: 10, unit: 'MINUTES') {
      input(id: 'userInput', message: 'Deploy to production?')
      canDeployToProd = true
    }
  } catch (err) {
    println "Timed out or Aborted! Will not deploy to production."
    println err
  }
  return canDeployToProd
}


return this
