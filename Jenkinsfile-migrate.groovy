@Library('common-pipelines@10.16.0') _

import groovy.transform.Field
import org.doordash.JenkinsDd

// -----------------------------------------------------------------------------------
//
// Pipeline for updating migrations for payment-service
//
// The following params are automatically provided by the callback gateway as inputs
// to the Jenkins pipeline that starts this job.
//
// params["SHA"]                    - Sha used to start the pipeline
// params["BRANCH_NAME"]            - Name of GitHub branch the SHA is associated with
// params["UNIQUE_BUILD_ID"]        - A randomly generated unique ID for this job run
// params["ENQUEUED_AT_TIMESTAMP"]  - Unix timestamp generated by callback gateway
// params["JSON"]                   - Extensible json doc with extra information
// params["GITHUB_REPOSITORY"]      - GitHub ssh url of repository (git://....)
// -----------------------------------------------------------------------------------

@Field
def canMigrateProd = false

@Field
def runningStage = "Not Started"

pipeline {
  options {
    timestamps()
    skipStagesAfterUnstable()
    timeout(time: 30, unit: 'MINUTES')
  }
  agent {
    label 'universal'
  }
  stages {
    stage('Migrate staging') {
      steps {
        script {
          runningStage = env.STAGE_NAME
          common = load "${WORKSPACE}/Jenkinsfile-common.groovy"
          common.notifySlackChannelDeploymentStatus(runningStage, params['SHA'], "${env.BUILD_NUMBER}", "started")
        }
        artifactoryLogin()
        script {
          env.tag = getImmutableReleaseSemverTag(params['SHA'])
          common.deployHelm(env.tag, 'payment-service-migration', 'staging')
        }
      }
    }
    stage('Reading migrate staging results') {
      steps {
        script {
          common.getMigrationJobLog('staging')
        }
      }
    }
    stage('Continue to prod?') {
      steps {
        script {
          runningStage = env.STAGE_NAME
          common.notifySlackChannelDeploymentStatus(runningStage, params['SHA'], "${env.BUILD_NUMBER}", "started")
        }
        script {
          canMigrateProd = common.inputCanDeployToProd()
          if (!canMigrateProd) {
            currentBuild.result = "ABORTED" /* Set current deployment to aborted */
          }
        }
      }
    }
    stage('Migrate prod') {
      when {
        equals expected: true, actual: canMigrateProd
      }
      steps {
        script {
          runningStage = env.STAGE_NAME
          common.notifySlackChannelDeploymentStatus(runningStage, params['SHA'], "${env.BUILD_NUMBER}", "started")
        }
        script {
          common.deployHelm(env.tag, 'payment-service-migration', 'prod')
        }
      }
    }
    stage('Reading migrate prod results') {
      steps {
        script {
          common.getMigrationJobLog('prod')
        }
      }
    }
  }
  post {
    success {
      script {
        common.notifySlackChannelDeploymentStatus("Successful Migration", params['SHA'], "${env.BUILD_NUMBER}", "success", true)
      }
    }
    aborted {
      script {
        common.notifySlackChannelDeploymentStatus("Aborted Migration", params['SHA'], "${env.BUILD_NUMBER}", "aborted", true)
      }
    }
    failure {
      script {
        common.notifySlackChannelDeploymentStatus("Failed Migration", params['SHA'], "${env.BUILD_NUMBER}", "failure", true)
      }
    }
  }
}
